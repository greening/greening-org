
<!--  Presentation generated by Internet Assistant for Microsoft PowerPoint 97 -->

<html>
<head>
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html;charset=windows-1252">
<meta name="GENERATOR" content="Microsoft Internet Assistant for Microsoft PowerPoint 97">
 <title>Scale Using Parallelism</title> 
<meta name="Microsoft Border" content="none, default">
</head>

<body>

<center>
<table WIDTH="100%"> 
     <tr> <td WIDTH="15%" ALIGN="CENTER">
         <a HREF="sld001.htm"><img SRC="first.gif" BORDER="0" ALT="First" WIDTH="40" HEIGHT="28"></a><br> 
         <a HREF="sld019.htm"><img SRC="prev.gif" BORDER="0" ALT="Previous" WIDTH="40" HEIGHT="28"></a><br> 
         <a HREF="sld021.htm"><img SRC="next.gif" BORDER="0" ALT="Next" WIDTH="40" HEIGHT="28"></a><br> 
         <a HREF="sld028.htm"><img SRC="last.gif" BORDER="0" ALT="Last" WIDTH="40" HEIGHT="28"></a><br> 
<br> 
         <a HREF="index.htm"><img SRC="info.gif" BORDER="0" ALT="Index" WIDTH="40" HEIGHT="28"></a><br> 
         <a HREF="/~greening/"><img SRC="home.gif" BORDER="0" ALT="Home" WIDTH="40" HEIGHT="28"></a><br> 
         <a HREF="tsld020.htm"><img SRC="text.gif" BORDER="0" ALT="Text" WIDTH="40" HEIGHT="28"></a><br> 
         <td WIDTH="85%" ALIGN="CENTER">         <img SRC="img020.gif" usemap="#Objmap" WIDTH="480" HEIGHT="360" BORDER="0">
         </td></tr></table>
<p>Slide 20 of 28</p>
</center>

 <center><font size="4"> <strong> Notes:  </font></strong><hr></center><p> <ul>
So, great.  You like the idea of personalization, but then you think &#147;geez, this is a lot of data and a lot of processing.&#148; You might be surprised that we run MovieCritic on an old 70MHz Sparc5 with an Informix database.  100,000 registered users.  Not bad.
</ul><ul>
Even so, if you have thousands of users interacting with your site simultaneously, you probably want to understand the parallelism model we use because you&#146;ll probably need it with any personalization solution.
</ul><ul>
The way others have dealt with scaling issues has been to choose less accurate algorithms, such as partitioning or &#147;clustering&#148;.  Or worse, they choose some surrogate like demographics.  These can be done fast because they are sloppy methods.
</ul><ul>
Instead, we figured out a cool way to parallelize the algorithm that limits locking.
</ul><ul>
On the left is the UI front end.  It only writes ratings.  On the right is the mentor identifier (or sifter as we call it).  It only writes mentor weights.  The prediction vectors are constructed in the front end on the fly.  And we will even do mentor identification on the fly from a front end cache, if necessary.
</ul><ul>
But still, the front end never writes out mentor weights.
</ul><ul>
These rules allow us to run full bore on a relational database without locking rows or tables.  It&#146;s funny how these little technerd things make a big difference in performance.</ul> </p> 
<!-- <UL><H2>Scale Using Parallelism</H2></UL></P><P><UL>Hashed Parallel Database</UL></P><P><UL>Mentor Identification</UL></P><P><UL>(background)</UL></P><P><UL>User Interface</UL></P><P><UL>Ring Buffer</UL></P><P><UL>Mentor Identifier</UL></P><P><UL>Ring Buffer</UL></P><P><UL>Mentor Identifier</UL></P><P><UL>Content</UL></P><P><UL>Server</UL></P><P><UL>Cache</UL></P><P><UL>Predictor</UL></P><P><UL>User rating/sample</UL></P><P><UL>Content</UL></P><P><UL>Server</UL></P><P><UL>Cache</UL></P><P><UL>Predictor</UL></P><P><UL>User rating/sample</UL></P><P>  -->
</body>
</html>
