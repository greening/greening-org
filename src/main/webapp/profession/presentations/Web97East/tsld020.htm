
<html>

<head>
<meta http-equiv="Content-Type" content="text/html;charset=windows-1252">
<meta name="GENERATOR" content="Microsoft Internet Assistant for PowerPoint 97">
 <title>Scales to Huge Sites</title> 
<meta name="Microsoft Border" content="none, default">
</head>

<body>

 <h1>Scales to Huge Sites</h1> 
 <p></p> 
<p>
<table>
  <td height="100" width="100"> <a href="tsld019.htm">Previous slide</a> </td>
  <td height="100" width="100"> <a href="tsld021.htm">Next slide</a> </td>
  <td height="100" width="150"> <a href="tsld001.htm">Back to first slide</a> </td>
  <td height="100" width="150"> <a href="sld020.htm">View graphic version</a> </td>
</table>
<br>
</p>

 <font size="4"><strong> Notes: </font></strong>
  <hr> <p> <ul>
So, great.  You like the idea of personalization, but then you think &#147;geez, this is a lot of data and a lot of processing.&#148; You might be surprised that we run MovieCritic on an old 70MHz Sparc5 with an Informix database.  100,000 registered users.  Not bad.
</ul><ul>
Even so, if you have thousands of users interacting with your site simultaneously, you probably want to understand the parallelism model we use because you&#146;ll probably need it with any personalization solution.
</ul><ul>
The way others have dealt with scaling issues has been to choose less accurate algorithms, such as partitioning or &#147;clustering&#148;.  Or worse, they choose some surrogate like demographics.  These can be done fast because they are sloppy methods.
</ul><ul>
Instead, we figured out a cool way to parallelize the algorithm that limits locking.
</ul><ul>
On the left is the UI front end.  It only writes ratings.  On the right is the mentor identifier (or sifter as we call it).  It only writes mentor weights.  The prediction vectors are constructed in the front end on the fly.  And we will even do mentor identification on the fly from a front end cache, if necessary.
</ul><ul>
But still, the front end never writes out mentor weights.
</ul><ul>
These rules allow us to run full bore on a relational database without locking rows or tables.  It&#146;s funny how these little technerd things make a big difference in performance.</ul> </p> 

</body>
</html>
